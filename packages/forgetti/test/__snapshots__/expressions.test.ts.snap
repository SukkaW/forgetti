// Vitest Snapshot v1

exports[`expressions > should optimize JSX Element 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { memo as _memo } from \\"react\\";
import { $$memo as _$$memo } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
const _Memo = _$$memo(_memo);
function Example(props) {
  let _c = _$$cache(_useRef, 10),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.title,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.title,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _v6 = _eq2 && _eq3 ? _c[5] : _c[5] = <_Memo value={<h1 title={_v3}>Title: {_v5}</h1>} />,
    _eq5 = _$$equals(_c, 6, _v6),
    _v7 = _eq5 ? _c[6] : _c[6] = _v6,
    _v8 = _eq ? _c[7] : _c[7] = _v.children,
    _eq6 = _$$equals(_c, 8, _v8),
    _v9 = _eq6 ? _c[8] : _c[8] = _v8;
  return _eq5 && _eq6 ? _c[9] : _c[9] = <_Memo value={<div>
      {_v7}
      {_v9}
    </div>} />;
}"
`;

exports[`expressions > should optimize JSX Fragment 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { memo as _memo } from \\"react\\";
import { $$memo as _$$memo } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
const _Memo = _$$memo(_memo);
function Example(props) {
  let _c = _$$cache(_useRef, 10),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.title,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.title,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _v6 = _eq2 && _eq3 ? _c[5] : _c[5] = <_Memo value={<h1 title={_v3}>Title: {_v5}</h1>} />,
    _eq5 = _$$equals(_c, 6, _v6),
    _v7 = _eq5 ? _c[6] : _c[6] = _v6,
    _v8 = _eq ? _c[7] : _c[7] = _v.children,
    _eq6 = _$$equals(_c, 8, _v8),
    _v9 = _eq6 ? _c[8] : _c[8] = _v8;
  return _eq5 && _eq6 ? _c[9] : _c[9] = <_Memo value={<>
      {_v7}
      {_v9}
    </>} />;
}"
`;

exports[`expressions > should optimize array expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 8),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.b,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _v6 = _eq ? _c[5] : _c[5] = _v.c,
    _eq4 = _$$equals(_c, 6, _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6;
  return _eq2 && _eq3 && _eq4 ? _c[7] : _c[7] = [_v3, _v5, ..._v7];
}"
`;

exports[`expressions > should optimize assignment expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 6),
    a,
    b,
    c,
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.x,
    _hoisted3 = c = _$$equals(_c, 2, _v2) ? _c[2] : _c[2] = _v2,
    _hoisted2 = b = _$$equals(_c, 3, _hoisted3) ? _c[3] : _c[3] = _hoisted3,
    _hoisted = a = _$$equals(_c, 4, _hoisted2) ? _c[4] : _c[4] = _hoisted2;
  _$$equals(_c, 5, _hoisted) ? _c[5] : _c[5] = _hoisted;
}"
`;

exports[`expressions > should optimize binary expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 6),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.b,
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  return _eq2 && _eq3 ? _c[5] : _c[5] = _v3 + _v5;
}"
`;

exports[`expressions > should optimize call expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 2),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props;
  return _eq ? _c[1] : _c[1] = _v.call();
}"
`;

exports[`expressions > should optimize conditional expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$branch as _$$branch } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 4),
    _eq = _$$equals(_c, 0, props),
    _v2 = _eq ? _c[0] : _c[0] = props,
    _v;
  if (_eq ? _c[1] : _c[1] = _v2.a) {
    let _c2 = _$$branch(_c, 2, 1);
    _v = _eq ? _c2[0] : _c2[0] = _v2.b;
  } else {
    let _c3 = _$$branch(_c, 3, 1);
    _v = _eq ? _c3[0] : _c3[0] = _v2.c;
  }
  return _v;
}"
`;

exports[`expressions > should optimize function expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 2),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props;
  const callback = _eq ? _c[1] : _c[1] = () => {
    console.log(props.message);
  };
}"
`;

exports[`expressions > should optimize guaranteed literals 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 1);
  return 0 in _c ? _c[0] : _c[0] = 1 + 2;
}"
`;

exports[`expressions > should optimize identifiers 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 1);
  return _$$equals(_c, 0, props) ? _c[0] : _c[0] = props;
}"
`;

exports[`expressions > should optimize logical expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$branch as _$$branch } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 3),
    _eq = _$$equals(_c, 0, props),
    _v2 = _eq ? _c[0] : _c[0] = props,
    _v3 = _eq ? _c[1] : _c[1] = _v2.a,
    _v;
  if (_v3) {
    let _c2 = _$$branch(_c, 2, 1);
    _v = _eq ? _c2[0] : _c2[0] = _v2.b;
  } else _v = _v3;
  return _v;
}"
`;

exports[`expressions > should optimize member expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 2),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props;
  return _eq ? _c[1] : _c[1] = _v.example;
}"
`;

exports[`expressions > should optimize new expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 3),
    _v = 0 in _c ? _c[0] : _c[0] = X,
    _eq = _$$equals(_c, 1, props),
    _v2 = _eq ? _c[1] : _c[1] = props;
  return _eq ? _c[2] : _c[2] = new _v(_v2);
}"
`;

exports[`expressions > should optimize object expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 6),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _v3 = _eq ? _c[2] : _c[2] = _v.b,
    _v4 = _eq ? _c[3] : _c[3] = _v.c,
    _eq2 = _$$equals(_c, 4, _v4),
    _v5 = _eq2 ? _c[4] : _c[4] = _v4;
  return _eq && _eq2 ? _c[5] : _c[5] = {
    a: _v2,
    b: _v3,
    ..._v5
  };
}"
`;

exports[`expressions > should optimize sequence expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 3),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props;
  return _eq ? _c[1] : _c[1] = _v.a(), _eq ? _c[2] : _c[2] = _v.b();
}"
`;

exports[`expressions > should optimize tagged templates 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 8),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.tag,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.a(),
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4,
    _v6 = _eq ? _c[5] : _c[5] = _v.b(),
    _eq4 = _$$equals(_c, 6, _v6),
    _v7 = _eq4 ? _c[6] : _c[6] = _v6;
  return _eq2 && _eq3 && _eq4 ? _c[7] : _c[7] = _v3\`\${_v5}, \${_v7}\`;
}"
`;

exports[`expressions > should optimize template literals 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 6),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a(),
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2,
    _v4 = _eq ? _c[3] : _c[3] = _v.b(),
    _eq3 = _$$equals(_c, 4, _v4),
    _v5 = _eq3 ? _c[4] : _c[4] = _v4;
  return _eq2 && _eq3 ? _c[5] : _c[5] = \`\${_v3}, \${_v5}\`;
}"
`;

exports[`expressions > should optimize unary expressions 1`] = `
"import { useRef as _useRef } from \\"react\\";
import { $$cache as _$$cache } from \\"forgetti/runtime\\";
import { $$equals as _$$equals } from \\"forgetti/runtime\\";
function Example(props) {
  let _c = _$$cache(_useRef, 4),
    _eq = _$$equals(_c, 0, props),
    _v = _eq ? _c[0] : _c[0] = props,
    _v2 = _eq ? _c[1] : _c[1] = _v.a,
    _eq2 = _$$equals(_c, 2, _v2),
    _v3 = _eq2 ? _c[2] : _c[2] = _v2;
  return _eq2 ? _c[3] : _c[3] = !_v3;
}"
`;
